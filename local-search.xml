<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS61B翻译</title>
    <link href="/2023/07/10/CS61B/"/>
    <url>/2023/07/10/CS61B/</url>
    
    <content type="html"><![CDATA[<h1 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h1><h2 id="pro0-2048"><a href="#pro0-2048" class="headerlink" title="pro0-2048"></a>pro0-2048</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>该项目的高级概述可以在<a href="https://youtu.be/Xzihuj_JZBI%E4%B8%AD%E6%89%BE%E5%88%B0%E3%80%82">https://youtu.be/Xzihuj_JZBI中找到。</a></p><p>该项目的目的是让您熟悉Java和课程中使用的各种工具，如IntelliJ IDE和JUnit用于编写和运行单元测试。尽管在proj0文件夹中有许多文件和大量代码，但您的任务仅限于Model.java文件，并且只需要编写四个方法。</p><p>我们将仅根据您是否成功使程序运行（根据我们的测试）和提交分配的部分来评分。没有隐藏的测试。在未来的任务中，我们还将对您的风格进行评分，但这并不适用于此项目。我们仍然建议遵循我们的style61b指南，因为您将发现它有助于创建清洁的代码，但您不会被评分。</p><p>该任务的规范非常长，有很多起始代码。我们建议您在开始编程之前阅读整个规范。一开始可能会感到压倒性。您可能需要多次重读规范的各个部分才能完全消化。有些较晚的部分可能直到您完成较早的部分后才完全理解。最终，我们希望您离开这个经验时能够感到掌握了如此庞大的任务的能力。</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>你可能已经看过并玩过Gabriele Cirulli编写的单人电脑游戏“2048”，它基于Veewo Studio的早期游戏“1024”（请参阅他的在线版本2048）。</p><p>在这个项目中，您将构建此游戏的核心逻辑。也就是说，我们已经编写好了所有GUI代码，处理按键，以及大量的其他脚手架。您的工作将是完成最重要和最有趣的部分。</p><p>具体而言，您将在Model.java文件中填写4个方法，这些方法控制用户按下某些键后会发生什么。</p><p>游戏本身非常简单。它在一个4x4的方格网格上进行，每个方格可以是空的或包含一个带有整数的方块 - 大于或等于2的2的幂。在第一步移动之前，应用程序将一个包含2或4的方块添加到最初空白的随机方格中。选择2或4是随机的，选择2的概率为75％，选择4的概率为25％。</p><p>然后，玩家通过箭头键选择方向来倾斜板：北，南，东或西。所有方块都向该方向滑动，直到该运动方向上没有空格（一开始可能没有）。方块可能会与另一个方块合并，从而赚取玩家积分。</p><p>下面的GIF是一个示例，展示了几个移动的结果。</p><p>以下是上面图像中显示的合并发生的完整规则。</p><p>1.两个相同值的方块合并为一个包含初始数字两倍的方块。</p><p>2.作为合并结果的方块在该倾斜中不会再次合并。例如，如果我们有[X，2，2，4]，其中X表示空格，并且我们将方块向左移动，我们应该最终得到[4，4，X，X]，而不是[8，X，X，X]。这是因为最左边的4已经参与了合并，因此不应再次合并。</p><p>3.当运动方向上的三个相邻方块具有相同的数字时，则在运动方向上的前两个方块合并，而后面的方块不会合并。例如，如果我们有[X，2，2，2]并将方块向左移动，我们应该最终得到[4，2，X，X]而不是[2，4，X，X]。</p><p>作为这些规则的一个推论，在运动方向上有四个相邻方块具有相同数字时，它们形成两个合并的方块。例如，如果我们有[4，4，4，4]，则如果我们向左移动，我们最终得到[8，8，X，X]。这是因为前两个方块将根据规则3合并，然后后面的两个方块将合并，但由于规则2，这些合并的方块（在我们的例子中为8）在该倾斜中不会再次合并。您可以在上面的动画GIF中找到上述每个规则的应用，因此请观看几次以充分理解这些规则。</p><p>为了测试您的理解，您应该完成这个Google表单测验。此测验不是您61B课程成绩的一部分。</p><p>如果倾斜没有改变棋盘状态，则不会随机生成新方块。否则，将在空方块上向棋盘添加一个随机生成的方块。注意：您的代码不会添加任何新方块！我们已经为您完成了这部分。</p><p>您可能还注意到屏幕底部有一个“得分”字段，每次移动都会更新该字段。得分不会在每次移动时都改变，而是仅在两个方块合并时才会改变。您的代码需要更新得分。</p><p>每次两个方块合并形成一个更大的方块时，玩家获得新方块上的分数。当当前玩家没有可用的移动（没有倾斜可以改变棋盘）或移动形成一个包含2048的方块时，游戏结束。您的代码将负责检测游戏何时结束。</p><p>“最高分”是用户在游戏会话中获得的最高分数。它直到游戏结束才会更新，因此在动画GIF示例中始终保持为0。</p><h3 id="Assignment-Philosophy-and-Program-Design"><a href="#Assignment-Philosophy-and-Program-Design" class="headerlink" title="Assignment Philosophy and Program Design"></a>Assignment Philosophy and Program Design</h3><p>这个项目中，我们为您提供了大量的起始代码，使用了许多Java语法，我们尚未涵盖，甚至包括一些我们永远不会在课堂上涵盖的语法。</p><p>这里的想法是，在现实世界中，您经常会使用您不完全理解的代码库，并且必须进行一些调整和实验以获得您想要的结果。别担心，当我们在下周开始项目1时，您将有机会从头开始。</p><p>下面，我们描述了给定骨架代码架构背后的一些思想，该代码由Paul Hilfinger创建。您不需要理解每个细节，但可能会发现它很有趣。</p><p>该骨架代码展示了两种常见的设计模式：模型-视图-控制器模式（MVC）和观察者模式。</p><p>MVC模式将我们的问题分为三个部分：</p><ol><li>模型（Model）代表被表示和操作的主题 - 在这种情况下，包括棋盘游戏的状态和修改规则。我们的模型驻留在Model、Side、Board和Tile类中。Model的实例变量完全确定了游戏的状态。注意：您只需要修改Model类。</li><li>视图（View）呈现模型的视图，向用户显示游戏状态。我们的视图驻留在GUI和BoardWidget类中。</li><li>游戏控制器（Controller）将用户的操作转换为模型上的操作。我们的控制器主要驻留在Game类中，尽管它还使用GUI类来读取按键。</li></ol><p>MVC模式不是61B课程的主题，您也不需要在考试或未来的项目中了解或理解这种设计模式。</p><p>第二种模式是“观察者模式”。基本上，这意味着模型实际上不会向视图报告更改。相反，视图将自己注册为Model对象的观察者。这是一个比较高级的话题，因此我们不会在这里提供额外的信息。</p><p>现在，我们将介绍您将与之交互的不同类。</p><h4 id="Tile"><a href="#Tile" class="headerlink" title="Tile"></a>Tile</h4><p>这个类代表棋盘上的编号方块。如果类型为Tile的变量为空（null），则它被视为棋盘上的空方块。您不需要创建任何这些对象，不过您需要了解它们，因为您将在Model类中使用它们。这个类唯一需要使用的方法是.value()，它返回给定方块的值。例如，如果Tile t对应于值为8的方块，则t.value()将返回8。</p><h4 id="Side"><a href="#Side" class="headerlink" title="Side"></a>Side</h4><p>Side类是一种特殊类型的枚举类。枚举类具有受限功能，特别是只能取有限集合中的一个值。在这种情况下，我们为4个方向中的每一个方向设置一个值：NORTH、SOUTH、EAST和WEST。您不需要使用此类的任何方法或操作实例变量。</p><p>可以使用类似 Side s &#x3D; Side.NORTH 的语法来分配枚举值。请注意，我们不是使用new关键字，而是将Side值设置为四个值之一。类似地，如果我们有一个函数如 public static void printSide(Side s)，我们可以调用这个函数如下：printSide(Side.NORTH)，这将把值NORTH传递给函数。</p><p>如果您想了解更多关于Java枚举的知识，请参阅<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html%E3%80%82">https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html。</a></p><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>这个类代表了游戏的整个状态。一个Model对象代表一个2048游戏。它具有实例变量来表示棋盘的状态（即所有Tile对象所在的位置，得分等），以及各种方法。在完成此项目的第四个和最后一个任务（编写倾斜方法）时，其中一个挑战将是确定哪些方法和实例变量是有用的。</p><h4 id="Board"><a href="#Board" class="headerlink" title="Board"></a>Board</h4><p>这个类代表了瓷砖棋盘本身。它有三个你会用到的方法：setViewingPerspective、tile、move。可选地，用于实验，您可以使用getRandomNonNullTile方法。</p><p>在此任务中，您只需编辑Model.java文件。Gradescope只会使用其他文件的框架版本获取您的Model.java文件，因此如果您编辑Tile.java文件，例如，它将不会被Gradescope识别。</p><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>首先，请确保您已经完成了实验1。如果您没有完成实验1中必要的设置，您将无法开始项目工作。</p><h4 id="Getting-the-skeleton-files"><a href="#Getting-the-skeleton-files" class="headerlink" title="Getting the skeleton files"></a>Getting the skeleton files</h4><p>首先，请确保您的存储库中的所有内容都已正确更新和签入。在开始之前，当在sp21-s<em><strong>目录中执行命令<code>git status</code>时，应报告目录已清除，并且没有应添加和提交的未跟踪文件。如果有，请添加并提交。<br>在开始新项目之前，绝不能不这样做。<br>要获取框架文件，您应该在sp21-s</strong></em>目录中使用以下命令<br><code>git pull skeleton master</code><br>您会看到一个名为proj0的文件夹包含所有骨架代码现在在您的学生存储库中。<br>在极少数情况下，如果我们必须更新框架，您可以使用相同的命令将您的项目与相同的更改更新。</p><h4 id="Getting-restarted-Skeleton"><a href="#Getting-restarted-Skeleton" class="headerlink" title="Getting restarted: Skeleton"></a>Getting restarted: Skeleton</h4><p>如果您发现自己想要完全重新开始，而不是尝试让您当前的代码工作，那么您可以使用Git！只需在sp21-s目录中运行以下命令<br><code>git checkout skeleton/master -- proj0</code><br>请注意：此命令将清除您尚未提交的proj0目录中任何内容的更改。因此，如果您认为可能需要您当前拥有的代码，请在运行此命令之前进行提交，然后您可以使用类似的命令将proj0目录还原到您刚刚提交的状态。</p><h3 id="Your-assignment"><a href="#Your-assignment" class="headerlink" title="Your assignment"></a>Your assignment</h3><p>您在这个项目中的任务是修改和完成Model类，特别是emptySpaceExists、maxTileExists、atLeastOneMoveExists和tilt方法。其他所有内容已经为您实现。我们建议按照以下顺序完成它们。前两个相对简单。第三个（atLeastOneMoveExists）比较困难，最后一个tilt方法可能会非常困难。我们预计tilt方法需要花费您3到10个小时的时间。前三个方法将处理游戏结束的条件，而最后一个tilt方法将在用户按键后修改棋盘。您可以阅读checkGameOver方法的非常简短的主体，以了解如何使用您的方法来检查游戏是否结束。</p><p>让我们先看看前三个方法：</p><h4 id="public-static-boolean-emptySpaceExists-Board-b"><a href="#public-static-boolean-emptySpaceExists-Board-b" class="headerlink" title="public static boolean emptySpaceExists(Board b)"></a>public static boolean emptySpaceExists(Board b)</h4><p>此方法应在给定的棋盘中任何一个格子为空时返回true。您不应在任何方式下修改Board.java文件。对于此方法，您将想要使用Board类的tile(int col, int row)和size()方法。没有其他方法是必要的。</p><p>注意：我们使用了特殊的关键字private来设计Board类，这样您就无法直接使用Board的实例变量。例如，如果您试图访问<code>b.values[][]</code>，这将不起作用。这是一件好事！它强迫您学习使用tile方法，在整个项目中都将使用它。</p><p>尝试打开TestEmptySpace.java文件夹。运行测试。您应该会看到6个测试失败，2个测试通过。在您正确编写emptySpaceExists方法之后，TestEmptySpace中的所有8个测试都应该通过。</p><p>以下是如何开始编写此方法的快速概述，可以在此视频中找到。</p><h4 id="public-static-boolean-maxTileExists-Board-b"><a href="#public-static-boolean-maxTileExists-Board-b" class="headerlink" title="public static boolean maxTileExists(Board b)"></a>public static boolean maxTileExists(Board b)</h4><p>如果棋盘中的任何一个方格等于获胜的方格值2048，则此方法应返回true。请注意，您不应该将常量2048硬编码到代码中，而应该使用MAX_PIECE，这是Model类的一部分的常量。换句话说，您不应该使用if (x &#x3D;&#x3D; 2048)，而应该使用if (x &#x3D;&#x3D; MAX_PIECE)。</p><p>保留硬编码数字（如2048）是一种不良的编程实践，有时被称为“神奇数字”。这些神奇数字的危险在于，如果您在代码的一个部分中更改它们而不在另一个部分中更改它们，则可能会获得意外的结果。通过使用像MAX_PIECE这样的变量，您可以确保它们都一起被更改。</p><p>在编写方法后，TestMaxTileExists.java中的测试应该通过。</p><h4 id="public-static-boolean-atLeastOneMoveExists-Board-b"><a href="#public-static-boolean-atLeastOneMoveExists-Board-b" class="headerlink" title="public static boolean atLeastOneMoveExists(Board b)"></a>public static boolean atLeastOneMoveExists(Board b)</h4><p>这个方法更具挑战性。如果有任何有效的移动，则它应该返回true。通过“有效移动”，我们的意思是，如果有一个按钮（UP、DOWN、LEFT或RIGHT），当用户玩2048时按下该按钮，会导致至少一个方格移动，那么这样的按键被认为是有效移动。</p><p>有两种情况下可以有有效的移动：</p><ul><li>棋盘上至少有一个空格。  </li><li>有两个相邻的具有相同值的方格。<br>例如，对于下面的棋盘，我们应该返回true，因为至少有一个空格。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">   2</span>|<span class="hljs-string">    </span>|<span class="hljs-string">   2</span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">   4</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<span class="hljs-string">   2</span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">   4</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   8</span>|<br></code></pre></td></tr></table></figure>对于下面的棋盘，我们应该返回false。无论您在2048中按哪个按钮，都不会发生任何事情，即没有两个相邻的具有相等值的方格。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<br>|<span class="hljs-string">  16</span>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<br>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<br>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<br></code></pre></td></tr></table></figure>对于下面的棋盘，我们会返回true，因为向右或向左移动会合并两个64方格，向上或向下移动也会合并32方格。换句话说，至少存在两个相邻的具有相等值的方格。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">  64</span>|<span class="hljs-string">  64</span>|<br>|<span class="hljs-string">  16</span>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   8</span>|<br>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<span class="hljs-string">  32</span>|<br>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">  32</span>|<br></code></pre></td></tr></table></figure>在编写方法后，TestAtLeastOneMoveExists.java中的测试应该通过。</li></ul><h3 id="Main-Task-Building-the-Game-Logic"><a href="#Main-Task-Building-the-Game-Logic" class="headerlink" title="Main Task: Building the Game Logic"></a>Main Task: Building the Game Logic</h3><p>任务的第四个和最后一个部分是实现tilt方法。只有在通过TestEmptySpace、TestMaxTileExists和TestAtLeastOneMoveExists中的所有测试后才应开始此方法。</p><p>计算机科学本质上是关于一件事情：管理复杂性。编写tilt方法是一次丰富的经历，将让您有机会尝试一下这方面的内容。我必须警告您，这可能会是一次令人沮丧的经历。在重新开始之前，您可能会尝试多种方法最终失败。</p><p>在我们开始讨论tilt应该如何工作之前，让我们尝试运行游戏。</p><p>打开Main类并单击运行按钮。您应该会看到游戏弹出。尝试按箭头键。您应该会发现没有任何反应。这是因为您尚未实现tilt方法。完成tilt编写后，您将能够玩游戏。</p><h4 id="public-boolean-tilt-Side-side"><a href="#public-boolean-tilt-Side-side" class="headerlink" title="public boolean tilt(Side side)"></a>public boolean tilt(Side side)</h4><p>倾斜法实际上是移动所有方块的方法。例如，如果我们有以下棋盘：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">   2</span>|<span class="hljs-string">    </span>|<span class="hljs-string">   2</span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">   4</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<span class="hljs-string">   2</span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">   4</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">   2</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   8</span>|<br></code></pre></td></tr></table></figure><p>按上键后，倾斜将修改棋盘实例变量，使游戏状态现在变为</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">   2</span>|<span class="hljs-string">   8</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   2</span>|<br>|<span class="hljs-string">   4</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   4</span>|<span class="hljs-string">   8</span>|<br>|<span class="hljs-string">   2</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br></code></pre></td></tr></table></figure><p>除了修改棋盘之外，还必须完成两件事：</p><ol><li>得分实例变量必须更新，以反映所有方块合并（如果有）的总值。对于上面的示例，我们将两个4合并为8，将两个2合并为4，因此得分应该增加8 + 4 &#x3D; 12。  </li><li>如果棋盘发生任何变化，我们必须将changed局部变量设置为true。这是因为在tilt的骨架代码的末尾，我们可以看到调用了setChanged()方法：这通知GUI有东西可以绘制。您不会自己调用setChanged：只修改changed局部变量即可。<br>所有棋盘上的方块移动必须使用Board类提供的move方法完成。必须使用Board类提供的tile方法访问棋盘上的所有方块。由于GUI实现中的一些细节，每次调用tilt时只应调用给定方块上的一次move。我们将在本文档的提示部分进一步讨论这个限制。</li></ol><p>此视频提供了一个快速概述如何开始编写此方法的信息。</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>我们强烈建议仅考虑向上方向，即提供的side参数等于Side.NORTH时。为了支持您，我们提供了一个TestUpOnly类，其中包含四个测试：testUpNoMerge、testUpBasicMerge、testUpTripleMerge和testUpTrickyMerge。您会注意到这些测试仅涉及单个向上移动。</p><p>在考虑如何实现向上方向时，请考虑以下内容：</p><p>在给定的列中，顶部行（第3行）上的方块保持不动。第2行上的方块如果上面的空间为空，则可以向上移动，或者如果上面的空间与其自身具有相同的值，则可以向上移动一次。换句话说，在迭代行时，从第3行向下迭代是安全的，因为一旦移动一次方块，就不可能再次移动。</p><p>尽管听起来不会很难，但实际上确实很难。准备好用记事本解决一堆例子。尽管优雅不易实现，但仍应力求代码简洁优雅。我们强烈建议创建一个或多个帮助方法来使代码保持整洁。例如，您可以有一个处理棋盘单列的帮助函数，因为每个列都是独立处理的。或者您可以有一个帮助函数，可以返回所需的行值。</p><p>提醒：在给定方块上只应调用一次move。换句话说，假设您有下面的棋盘并按上键。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">   2</span>|<br></code></pre></td></tr></table></figure><p>我们可以通过以下方式实现这一点：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Tile</span> t = board.tile(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)<br><span class="hljs-attribute">board</span>.move(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, t);<br><span class="hljs-attribute">board</span>.move(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, t);<br><span class="hljs-attribute">board</span>.move(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, t);<br><span class="hljs-attribute">setChanged</span>();<br><span class="hljs-attribute">return</span> true;<br></code></pre></td></tr></table></figure><p>然而，GUI会感到困惑，因为同一个tile不应该只调用一次setChanged就移动多次。相反，你需要用一次调用来完成整个移动，例如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Tile</span> t = board.tile(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)<br><span class="hljs-attribute">board</span>.move(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, t);<br></code></pre></td></tr></table></figure><p>在某种意义上，难点在于弄清楚每个方块应该结束在哪一行。</p><p>为了测试您的理解，您应该完成这个Google表单测验。这个测验（和以下测验）完全是可选的（即不计分），但强烈建议参加，因为它可以发现您可能对游戏机制存在的任何概念误解。您可以尝试多次进行此测验。</p><p>要知道何时应该更新得分，请注意board.move(c, r, t)方法，如果将方块t移动到列c和行r将替换现有方块，则返回true（即您进行了合并操作）。</p><p>更糟糕的是，即使在您使倾斜函数在向上方向正常工作后，您还必须对其他三个方向执行相同的操作。如果您天真地这样做，您将得到许多重复的、稍微修改过的代码，而且容易引入难以排查的错误。</p><p>针对这个问题，我们提供了一个简洁的解决方案。这将使您只需额外两行代码就能处理其他三个方向！具体来说，Board类有一个setViewingPerspective（Side s）函数，它将更改tile和move类的行为，使它们表现得好像给定的方向是NORTH。<br>例如，考虑下面的棋盘：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">  16</span>|<span class="hljs-string">    </span>|<span class="hljs-string">  16</span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">   2</span>|<br></code></pre></td></tr></table></figure><p>如果我们调用board.tile(0, 2)，我们将得到16，因为16在列0行2。如果我们调用board.setViewingPerspective(s)，其中s是WEST，则棋盘将表现得好像WEST是NORTH，即您将头向左转90度，如下所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  16</span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  16</span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">   2</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br></code></pre></td></tr></table></figure><p>换句话说，我们之前的16将在board.tile(2, 3)处。如果我们使用正确实现的tilt调用board.tilt(Side.NORTH)，则棋盘将变为：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">   2</span>|<span class="hljs-string">    </span>|<span class="hljs-string">  32</span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br></code></pre></td></tr></table></figure><p>为了使棋盘回到原始视角，我们只需调用board.setViewingPerspective(Side.NORTH)，这将使棋盘表现得好像NORTH是NORTH。如果我们这样做，棋盘现在将表现得好像它是：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">  32</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">   2</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br></code></pre></td></tr></table></figure><p>请注意，这与您将原始棋盘的方块向WEST滑动相同。</p><p>重要提示：确保在完成tilt调用之前使用board.setViewingPerpsective将视角设置回Side.NORTH，否则会发生奇怪的事情。</p><p>为了测试您的理解，请尝试这个第三个也是最后一个Google表单测验。您可以尝试多次进行此测验。</p><h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>虽然在未来我们希望您能够测试自己的程序，但对于这个项目，我们已经为您提供了完整的测试套件。</p><p>测试被分成5个文件：TestEmptySpace、TestMaxTileExists、TestAtLeastOneMoveExists、TestUpOnly和TestModel。每个文件测试特定部分的代码，除了TestModel以外，它测试您协调编写的所有内容。这样的测试被称为集成测试，在测试中非常重要。虽然单元测试在隔离的环境中运行，但集成测试将所有东西一起运行，旨在捕捉由于您编写的不同函数之间的交互而产生的难以排查的错误。</p><p>因此，在您通过其他测试之前，请不要尝试调试TestModel！实际上，我们讨论测试的顺序就是您应该尝试测试的顺序。</p><p>现在，我们将查看每个测试并向您展示如何读取错误消息。</p><h4 id="TestEmptySpace"><a href="#TestEmptySpace" class="headerlink" title="TestEmptySpace"></a>TestEmptySpace</h4><p>这些测试将检查您的emptySpaceExists方法的正确性。如果您未通过其中一个测试，则错误消息将如下所示：<br><img src="http://img.jianzha.site/20230705213204.png"></p><p>在左侧，您将看到运行的所有测试的列表。黄色的 X 表示我们未通过测试，绿色的勾表示我们通过了测试。在右侧，您将看到一些有用的错误消息。要单独查看单个测试及其错误消息，请单击左侧的测试。例如，假设我们想查看testCompletelyEmpty测试。</p><p><img src="http://img.jianzha.site/20230705213253.png"></p><p>右侧现在是此测试的独立错误消息。顶部有一个有用的消息：“棋盘充满了空格”，后面跟着一个表示棋盘的字符串表示形式。您将看到它显然是空的，但我们的emptySpaceExists方法返回false，导致此测试失败。代码顶部的javadoc注释也包含一些有用的信息，以防您未通过测试。</p><h4 id="TestMaxTileExists"><a href="#TestMaxTileExists" class="headerlink" title="TestMaxTileExists"></a>TestMaxTileExists</h4><p>这些测试将检查您的maxTileExists方法的正确性。错误消息与TestEmptySpace的错误消息类似，您仍然可以单击每个单独测试来查看它们。请记住，您的maxTileExists方法应该只查找最大的方块，而不是其他任何内容（即不应查找空格）。如果您的方法这样做了，您将无法通过所有这些测试。</p><h4 id="TestAtLeastOneMoveExists"><a href="#TestAtLeastOneMoveExists" class="headerlink" title="TestAtLeastOneMoveExists"></a>TestAtLeastOneMoveExists</h4><p>这些测试将检查您的atLeastOneMoveExists方法的正确性。错误消息类似于上述两个测试。由于atLeastOneMoveExists方法依赖于emptySpaceExists方法，因此在通过TestEmptySpace中的所有测试之前，您不应该期望通过这些测试。</p><h4 id="TestUpOnly"><a href="#TestUpOnly" class="headerlink" title="TestUpOnly"></a>TestUpOnly</h4><p>这些测试将检查您的tilt方法的正确性，但仅针对向上（Side.NORTH）方向。这些测试的错误消息不同，因此让我们看一个例子。假设我们运行了所有测试，注意到我们未通过testUpTrickyMerge测试。单击该测试后，我们将看到以下内容：</p><p><img src="http://img.jianzha.site/20230705213532.png"></p><p>第一行告诉我们进行倾斜的方向（对于这些测试，它将始终是North），然后是倾斜前棋盘的样子，然后是我们预期的棋盘样子，最后是您的棋盘实际的样子。</p><p>您将看到我们在单次tilt调用中两次合并一个方块，这导致一个值为8的单个方块，而不是两个值为4的方块。因此，我们的得分也是不正确的，如您在棋盘表示形式的底部所见。</p><p>对于其他测试，可能很难立即注意到预期棋盘和实际棋盘之间的差异。对于这些测试，您可以单击错误消息底部的蓝色“单击查看差异”文本，以在单独的窗口中获取预期棋盘（左侧）和实际棋盘（右侧）的并排比较。以下是此测试的比较结果：<br><img src="http://img.jianzha.site/20230705213914.png"></p><p>调试这些测试可能有点棘手，因为很难确定您做错了什么。首先，您应该确定您违反了上面列出的3个规则中的哪一个。在这种情况下，我们可以看到这是规则2，因为一个方块合并了多次。这些方法的javadoc注释是很好的资源，因为它们明确说明了它们正在测试哪个规则&#x2F;配置。您还可以通过查看棋盘的前后状态来确定您违反了哪个规则。然后，就是棘手的部分：重构您现有的代码以正确地考虑该规则。我们建议在纸上写出代码的步骤，以便您首先了解您的棋盘为什么会出现这种情况，然后再想出解决方法。这些测试仅调用一次tilt，因此您不需要担心调试多次调用tilt。</p><h4 id="TestModel"><a href="#TestModel" class="headerlink" title="TestModel"></a>TestModel</h4><p>这些测试将检查所有内容的正确性。其中大部分测试与TestUpOnly中的测试类似，因为它们仅调用一次tilt，但是我们还对gameOver进行了测试（测试您的emptySpaceExists、maxTileExists和atLeastOneMoveExists方法的所有内容），以及对tilt进行多次调用的测试。</p><p>这些测试的错误消息与TestUpOnly中的错误消息完全相同，javadoc注释同样有用，可以帮助您弄清楚测试正在测试什么。</p><p>不要担心测试的实际代码：您不需要理解或修改其中任何内容，但是如果您感到非常有雄心壮志，可以阅读并了解测试编写的工作原理，甚至添加自己的测试。</p><h3 id="Grading"><a href="#Grading" class="headerlink" title="Grading"></a>Grading</h3><p>完全得分的项目将通过我们提供的所有单元测试。请记住，没有隐藏的测试，因此如果您通过了所有这些测试，则具有完全得分的项目！</p><p>在Gradescope上，某些测试的权重略有不同，因此如果您未通过某些测试的某些部分，则您的得分百分比将是某个不同的分数（可能更高）。</p><p>这是因为该项目的某些部分比其他部分更困难，而我们知道这是许多学生第一次使用Java，因此我们考虑了项目的每个部分的权重。</p><p>以下是您完成不同水平的项目可以获得的百分比的细分：</p><ol><li>仅实现emptySpaceExists或maxTileExists：约27％  </li><li>实现除tilt以外的所有内容：约47％  </li><li>实现所有内容，除了tilt仅在向上方向起作用：约68％  </li><li>实现所有内容，除了合并：约64％  </li><li>实现所有内容，除了合并的规则2：约93％<br>您会注意到，获取合并的规则2仅占项目的约7％。这是因为这是一条难以处理的规则，仅占游戏本身的很小一部分，因此我们相应地进行了加权。</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS61B</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
